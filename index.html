<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minimal Jump — 3 schwere Levels</title>
<style>
  :root{
    --bg:#0f1720;
    --panel:#0f1720;
    --card:#0f1a24;
    --accent: #6ee7b7;
    --muted:#9aa6b2;
    --white:#e6eef6;
    --danger:#ff6b6b;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#08121a);color:var(--white);-webkit-font-smoothing:antialiased}
  .container{max-width:1100px;margin:28px auto;padding:18px;border-radius:12px}
  header{display:flex;align-items:center;gap:18px}
  h1{margin:0;font-size:1.4rem;letter-spacing:0.2px}
  .layout{display:grid;grid-template-columns:1fr 300px;gap:20px;margin-top:18px}
  .gameCard{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));border-radius:12px;padding:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  canvas{display:block;width:100%;height:560px;border-radius:8px;background:
    linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));outline:1px solid rgba(255,255,255,0.02)}
  aside{display:flex;flex-direction:column;gap:12px}
  .panel{padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03)}
  .stat{display:flex;justify-content:space-between;align-items:center;font-weight:600;color:var(--muted)}
  .big{font-size:1.2rem;color:var(--white)}
  .controls{font-size:0.9rem;color:var(--muted);line-height:1.6}
  .btn{padding:8px 10px;border-radius:8px;border:none;background:transparent;color:var(--accent);cursor:pointer;font-weight:700}
  .btn-contained{background:var(--accent);color:#05221a;border:none;padding:9px;border-radius:8px;font-weight:700;cursor:pointer}
  .progress{height:10px;background:rgba(255,255,255,0.03);border-radius:6px;overflow:hidden}
  .bar{height:100%;background:linear-gradient(90deg,var(--accent),#3ee0c0);width:0%}
  footer{margin-top:12px;color:var(--muted);font-size:0.85rem}
  @media (max-width:980px){.layout{grid-template-columns:1fr;}.container{margin:12px}}
  /* little visual for platform/enemy/goal */
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Minimal Jump — 3 schwere Levels</h1>
    <div style="margin-left:auto;color:var(--muted);font-size:0.95rem">Design: minimalistisch · Keine Sounds</div>
  </header>

  <div class="layout">
    <div class="gameCard">
      <canvas id="game"></canvas>
      <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
        <div class="stat">Leben: <span id="lives" class="big">3</span></div>
        <div class="stat">Punkte: <span id="score" class="big">0</span></div>
        <div class="stat">Level: <span id="level" class="big">1</span></div>
        <button id="restart" class="btn" style="margin-left:auto">Restart Level</button>
        <button id="resetAll" class="btn" title="Reset aller Fortschritte">Reset</button>
      </div>
    </div>

    <aside>
      <div class="panel">
        <div class="stat"><div style="font-weight:700">Ziel</div><div style="color:var(--muted)">Erreiche das grüne Tor</div></div>
        <div style="height:8px"></div>
        <div class="stat"><div style="font-weight:700;color:var(--muted)">Schwierigkeit</div><div style="font-weight:800">Schwer — mehrere Fallen & bewegliche Gegner</div></div>
      </div>

      <div class="panel">
        <div style="font-weight:700;margin-bottom:6px">Steuerung</div>
        <div class="controls">
          ← / A = links • → / D = rechts • ↑ / W / Leertaste = springen<br>
          R = Level neu starten • P = Pause
        </div>
      </div>

      <div class="panel">
        <div style="font-weight:700">Fortschritt</div>
        <div style="height:8px"></div>
        <div class="progress"><div id="progressBar" class="bar"></div></div>
        <div style="margin-top:8px;color:var(--muted)">Highscore (Local): <span id="highscore">0</span></div>
      </div>

      <div class="panel">
        <div style="font-weight:700;margin-bottom:6px">Tipps</div>
        <div style="color:var(--muted);font-size:0.95rem;line-height:1.5">
          • Timing beim Doppel-/langen Sprung ist entscheidend.<br>
          • Beobachte bewegliche Plattformen bevor du springst.<br>
          • Gegner können übersprungen oder vermieden werden.
        </div>
      </div>
    </aside>
  </div>

  
</div>

<script>
/*
Minimal Jump — 3 schwere Levels
Single-file, keine externen Assets, keine Sounds.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });

function fitCanvas(){
  // logical resolution for crisp physics
  const ratio = Math.min(1100, Math.max(600, window.innerWidth-120));
  canvas.width = Math.floor(ratio);
  canvas.height = 560;
}
fitCanvas();
window.addEventListener('resize', ()=>{ fitCanvas(); draw() });

/* Game state */
let state = {
  running: true,
  paused: false,
  levelIndex: 0,
  lives: 3,
  score: 0,
  player: null,
  entities: [],
  time: 0,
  levelProgress: 0
};

const ui = {
  lives: document.getElementById('lives'),
  score: document.getElementById('score'),
  level: document.getElementById('level'),
  highscore: document.getElementById('highscore'),
  progressBar: document.getElementById('progressBar')
};

const HIGHKEY = 'minimal_jump_highscore';
ui.highscore.textContent = localStorage.getItem(HIGHKEY) || '0';

/* Controls */
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'p'){ state.paused = !state.paused; }
  if(e.key.toLowerCase() === 'r'){ startLevel(state.levelIndex); }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

/* Helper collision */
function rectsCollide(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

/* Player */
function createPlayer(x,y){
  return {
    type: 'player',
    x, y,
    w: 32, h: 48,
    vx: 0, vy: 0,
    onGround: false,
    canDoubleJump: true,
    color: '#dbeafe'
  };
}

/* Levels definition
Each level contains:
 platforms: [{x,y,w,h, type? }]
 enemies: [{x,y,w,h, vx, patrolRange}]
 goal: {x,y,w,h}
 start: {x,y}
*/
const LEVELS = [
  // LEVEL 1 - hard: moving platforms, spikes, patrolling enemies, narrow jumps
  {
    gravity: 1500,
    friction: 0.9,
    start: {x:40, y:460},
    goal: {x: 980, y: 500, w: 40, h: 56},
    platforms: [
      {x:0,y:520,w:1200,h:40}, // ground
      {x:160,y:430,w:120,h:16},
      {x:320,y:360,w:120,h:16},
      {x:520,y:300,w:120,h:16},
      {x:700,y:240,w:120,h:16},
      {x:860,y:320,w:120,h:16},
      // moving platform
      {x:420,y:460,w:90,h:14, move: {axis:'x', from:420, to:700, speed:60}}
    ],
    spikes: [
      {x:240,y:520-12,w:40,h:12},
      {x:560,y:520-12,w:40,h:12}
    ],
    enemies: [
      {x:360,y:320,w:32,h:32,vx:60,range:60},
      {x:740,y:200,w:32,h:32,vx:80,range:100}
    ],
    timeLimit: null // no timer
  },

  // LEVEL 2 - harder: falling platforms, narrow passage, faster enemies
  {
    gravity: 1600,
    friction: 0.92,
    start: {x:40, y:460},
    goal: {x: 980, y: 200, w: 40, h: 56},
    platforms: [
      {x:0,y:520,w:1200,h:40},
      {x:140,y:420,w:90,h:16},
      {x:260,y:360,w:90,h:16, fallOnTouch: true}, // falling
      {x:420,y:300,w:60,h:16},
      {x:520,y:240,w:60,h:16},
      {x:640,y:180,w:140,h:16},
      {x:820,y:140,w:120,h:16}
    ],
    spikes: [
      {x:360,y:520-12,w:60,h:12},
      {x:660,y:520-12,w:60,h:12}
    ],
    enemies: [
      {x:200,y:320,w:36,h:36,vx:90,range:100},
      {x:560,y:260,w:36,h:36,vx:100,range:140}
    ],
    timeLimit: null
  },

  // LEVEL 3 - hardest: narrow moving platforms, dash enemies, gaps
  {
    gravity: 1700,
    friction: 0.94,
    start: {x:40, y:460},
    goal: {x: 1020, y: 460, w: 40, h: 56},
    platforms: [
      {x:0,y:520,w:1200,h:40},
      {x:120,y:420,w:80,h:16},
      {x:240,y:360,w:70,h:16, move: {axis:'y', from:360, to:240, speed:50}},
      {x:360,y:300,w:70,h:16},
      {x:500,y:260,w:60,h:16, move: {axis:'x', from:500, to:760, speed:90}},
      {x:700,y:340,w:60,h:16},
      {x:820,y:260,w:60,h:16},
      {x:920,y:420,w:100,h:16}
    ],
    spikes: [
      {x:320,y:520-12,w:40,h:12},
      {x:440,y:520-12,w:40,h:12},
      {x:760,y:520-12,w:60,h:12}
    ],
    enemies: [
      {x:300,y:320,w:36,h:36,vx:140,range:160, type:'dash'},
      {x:680,y:320,w:36,h:36,vx:120,range:120}
    ],
    timeLimit: null
  }
];

/* Initialize or restart level */
function startLevel(n){
  state.levelIndex = n;
  const L = LEVELS[n];
  state.gravity = L.gravity;
  state.friction = L.friction;
  state.player = createPlayer(L.start.x, L.start.y);
  state.entities = [];
  state.entities.push(...L.platforms.map(p => ({...p, type:'platform', initX:p.x, initY:p.y})));
  state.entities.push(...L.spikes ? L.spikes.map(s => ({...s, type:'spike'})) : []);
  state.entities.push(...L.enemies ? L.enemies.map(e => ({...e, type:'enemy', startX:e.x, patrolDir:1, dead:false, cooldown:0})) : []);
  state.entities.push({...L.goal, type:'goal'});
  state.time = 0;
  ui.level.textContent = n+1;
  ui.lives.textContent = state.lives;
  ui.score.textContent = state.score;
  updateProgress();
  draw();  
}
document.getElementById('restart').addEventListener('click', ()=> startLevel(state.levelIndex));
document.getElementById('resetAll').addEventListener('click', ()=>{ state.score = 0; state.lives = 3; localStorage.removeItem(HIGHKEY); ui.highscore.textContent = '0'; startLevel(0); });

/* Physics & update loop */
let last = performance.now();
function step(now){
  const dt = Math.min(0.035, (now - last) / 1000);
  last = now;
  if(!state.paused){
    update(dt);
    draw();
  } else {
    // draw pause overlay
    draw();
    ctx.fillStyle = 'rgba(6,8,10,0.6)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#dbeafe';
    ctx.font = '28px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSE', canvas.width/2, canvas.height/2);
  }
  requestAnimationFrame(step);
}
requestAnimationFrame(step);

function update(dt){
  state.time += dt;

  const p = state.player;
  const L = LEVELS[state.levelIndex];

  // input
  const left = keys['arrowleft'] || keys['a'];
  const right = keys['arrowright'] || keys['d'];
  const up = keys['arrowup'] || keys['w'] || keys[' '];

  // horizontal accel
  const accel = 1400;
  if(left) p.vx -= accel * dt;
  if(right) p.vx += accel * dt;
  // friction
  p.vx *= Math.pow(state.friction, dt*60);

  // gravity
  p.vy += state.gravity * dt;

  // jump
  if(up && (p.onGround || p.canDoubleJump)){
    if(p.onGround){
      p.vy = -650;
      p.onGround = false;
      p.canDoubleJump = true;
    } else if(p.canDoubleJump){
      p.vy = -540;
      p.canDoubleJump = false;
    }
    // prevent auto repeated jump
    keys[' '] = false; keys['w']=false; keys['arrowup']=false;
  }

  // clamp speed
  const maxVx = 420;
  p.vx = Math.max(-maxVx, Math.min(maxVx, p.vx));
  p.x += p.vx * dt;
  p.y += p.vy * dt;

  // world boundaries
  if(p.x < 0) p.x = 0, p.vx = 0;
  if(p.x + p.w > canvas.width) p.x = canvas.width - p.w, p.vx = 0;

  // reset on fall
  if(p.y > canvas.height + 100){
    playerDie();
    return;
  }

  // update moving platforms and enemies
  state.entities.forEach(ent => {
    if(ent.type === 'platform' && ent.move){
      const m = ent.move;
      if(m.axis === 'x'){
        // simple ping-pong
        const span = m.to - m.from;
        const phase = ((state.time * m.speed) % (2*span)) / (2*span);
        ent.x = m.from + (phase <= 0.5 ? phase*2*span : (1 - (phase-0.5)*2)*span);
      } else if(m.axis === 'y'){
        const span = m.to - m.from;
        const phase = ((state.time * m.speed) % (2*Math.abs(span))) / (2*Math.abs(span));
        ent.y = m.from + (phase <= 0.5 ? phase*2*span : (1 - (phase-0.5)*2)*span);
      }
    }
    if(ent.type === 'enemy'){
      // patrol logic
      if(ent.type && !ent.dead){
        if(ent.type === 'enemy'){
          if(ent.hasOwnProperty('type') && ent.type === 'enemy'){
            // 'dash' enemy behaves similarly but higher vx
            const eDef = LEVELS[state.levelIndex].enemies.find(x => x.startX === ent.startX && x.w === ent.w) || {};
            const speed = eDef.vx || ent.vx;
            ent.x += ent.patrolDir * speed * dt;
            // reverse when out of range
            if(Math.abs(ent.x - ent.startX) > (eDef.range || ent.range || 80)) ent.patrolDir *= -1;
            // small cooldown to avoid immediate repeated hits
            if(ent.cooldown > 0) ent.cooldown = Math.max(0, ent.cooldown - dt);
          }
        }
      }
    }
  });

  // collisions: platforms (simple AABB resolution)
  p.onGround = false;
  for(let ent of state.entities){
    if(ent.type === 'platform'){
      const plat = ent;
      // AABB overlap check
      const next = {x: p.x, y: p.y, w: p.w, h: p.h};
      if(rectsCollide(next, plat)){
        // simple resolution: check previous position to determine collision side
        const prevY = p.y - p.vy*dt;
        const prevX = p.x - p.vx*dt;
        if(prevY + p.h <= plat.y + 6){ // landed on top
          p.y = plat.y - p.h;
          p.vy = 0;
          p.onGround = true;
          p.canDoubleJump = true;
          // falling platform?
          if(plat.fallOnTouch && !plat._fallen){
            plat._fallen = true;
            // start falling
            setTimeout(()=>{ plat.y += 400; }, 220); // visually drop
          }
        } else if(prevY >= plat.y + plat.h - 6){ // hit from below
          p.y = plat.y + plat.h + 1;
          p.vy = 0;
        } else { // side collision
          if(prevX + p.w <= plat.x + 6){ p.x = plat.x - p.w; p.vx = 0; }
          else if(prevX >= plat.x + plat.w - 6){ p.x = plat.x + plat.w; p.vx = 0; }
        }
      }
    }

    if(ent.type === 'spike' && rectsCollide(p, ent)){
      playerDie();
      return;
    }

    if(ent.type === 'enemy' && !ent.dead && rectsCollide(p, ent)){
      if(p.vy > 150 && p.y + p.h - 8 < ent.y + 4){
        // stomp enemy
        ent.dead = true;
        state.score += 20;
        ui.score.textContent = state.score;
        ent.cooldown = 0.6;
        p.vy = -360;
      } else {
        playerHurt(ent);
        return;
      }
    }

    if(ent.type === 'goal' && rectsCollide(p, ent)){
      // level complete
      levelComplete();
      return;
    }
  }

  // enemies collisions with world edges: keep within patrol range already handled

  // update UI and progress
  ui.lives.textContent = state.lives;
  ui.score.textContent = state.score;
  updateProgress();
}

/* Player death/hurt */
function playerDie(){
  state.lives -= 1;
  ui.lives.textContent = state.lives;
  if(state.lives <= 0){
    // game over -> reset everything
    const previousHigh = parseInt(localStorage.getItem(HIGHKEY) || '0',10);
    if(state.score > previousHigh) localStorage.setItem(HIGHKEY, String(state.score));
    ui.highscore.textContent = localStorage.getItem(HIGHKEY) || '0';
    // show game over screen briefly then restart
    overlayMessage('GAME OVER — Restarting level', 1500, ()=>{ state.score = 0; state.lives = 3; startLevel(0); });
  } else {
    overlayMessage('Du hast ein Leben verloren', 900, ()=> startLevel(state.levelIndex));
  }
}

function playerHurt(enemy){
  // short invulnerability & push back
  state.lives -= 1;
  ui.lives.textContent = state.lives;
  state.player.vx = -Math.sign(state.player.x - enemy.x) * 240;
  state.player.vy = -240;
  enemy.cooldown = 0.6;
  if(state.lives <= 0) playerDie();
  else {
    overlayMessage('Triff: -1 Leben', 800);
  }
}

/* Level complete */
function levelComplete(){
  state.score += 100 + Math.max(0, 200 - Math.floor(state.time*10));
  ui.score.textContent = state.score;
  overlayMessage('LEVEL GELÖST', 1000, ()=>{
    const next = state.levelIndex + 1;
    const previousHigh = parseInt(localStorage.getItem(HIGHKEY) || '0',10);
    if(state.score > previousHigh) localStorage.setItem(HIGHKEY, String(state.score));
    ui.highscore.textContent = localStorage.getItem(HIGHKEY) || '0';
    if(next >= LEVELS.length){
      overlayMessage('ALLE LEVEL BESTANDEN — Spiel beendet', 1600, ()=> startLevel(0));
      state.lives = 3;
      state.score = 0;
    } else {
      startLevel(next);
    }
  });
}

/* small overlay message */
let _overlayTimer = null;
function overlayMessage(text, ms=1000, cb=null){
  const overlay = {text, expires: performance.now() + ms, cb};
  state._overlay = overlay;
  if(_overlayTimer) clearTimeout(_overlayTimer);
  _overlayTimer = setTimeout(()=>{
    if(state._overlay && state._overlay.cb) state._overlay.cb();
    state._overlay = null;
  }, ms);
}

/* draw */
function draw(){
  // clear
  ctx.fillStyle = '#071018';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // background grid subtle
  ctx.strokeStyle = 'rgba(255,255,255,0.02)';
  ctx.lineWidth = 1;
  for(let i=0;i<canvas.width;i+=48){
    ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,canvas.height); ctx.stroke();
  }

  // entities
  for(let ent of state.entities){
    if(ent.type === 'platform'){
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      roundRect(ctx, ent.x, ent.y, ent.w, ent.h, 4);
      ctx.fill();
      // platform border
      ctx.strokeStyle = 'rgba(255,255,255,0.04)';
      ctx.strokeRect(ent.x, ent.y, ent.w, ent.h);
    }
    if(ent.type === 'spike'){
      // draw simple spike
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.moveTo(ent.x, ent.y + ent.h);
      ctx.lineTo(ent.x + ent.w/2, ent.y);
      ctx.lineTo(ent.x + ent.w, ent.y + ent.h);
      ctx.closePath();
      ctx.fill();
    }
    if(ent.type === 'enemy'){
      ctx.fillStyle = ent.dead ? 'rgba(200,200,200,0.12)' : '#ffcf6b';
      ctx.fillRect(ent.x, ent.y, ent.w, ent.h);
      // eye
      ctx.fillStyle = '#082028';
      ctx.fillRect(ent.x + ent.w/4, ent.y + ent.h/4, ent.w/4, ent.h/4);
    }
    if(ent.type === 'goal'){
      ctx.fillStyle = '#6ee7b7';
      roundRect(ctx, ent.x, ent.y, ent.w, ent.h, 6);
      ctx.fill();
      ctx.strokeStyle = 'rgba(2,6,8,0.5)';
      ctx.strokeRect(ent.x, ent.y, ent.w, ent.h);
      // gate detail
      ctx.fillStyle = 'rgba(2,6,8,0.06)';
      ctx.fillRect(ent.x+6, ent.y+6, ent.w-12, ent.h-12);
    }
  }

  // player
  const p = state.player;
  if(p){
    ctx.fillStyle = '#dbeafe';
    roundRect(ctx, p.x, p.y, p.w, p.h, 6);
    ctx.fill();
    // face detail
    ctx.fillStyle = '#082028';
    ctx.fillRect(p.x + 8, p.y + 12, 6, 6);
    ctx.fillRect(p.x + p.w - 14, p.y + 12, 6, 6);
  }

  // overlay text
  if(state._overlay){
    ctx.fillStyle = 'rgba(6,8,10,0.6)';
    ctx.fillRect(canvas.width/2 - 260, canvas.height/2 - 46, 520, 92);
    ctx.fillStyle = '#e6eef6';
    ctx.font = '22px Inter, Arial';
    ctx.textAlign = 'center';
    ctx.fillText(state._overlay.text, canvas.width/2, canvas.height/2 + 8);
  }
}

/* helpers */
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y, x+w,y+h, r);
  ctx.arcTo(x+w,y+h, x,y+h, r);
  ctx.arcTo(x,y+h, x,y, r);
  ctx.arcTo(x,y, x+w,y, r);
  ctx.closePath();
}

/* progress bar update */
function updateProgress(){
  const total = LEVELS.length;
  const cur = state.levelIndex + 1;
  const pct = Math.round((cur/total) * 100);
  ui.progressBar.style.width = pct + '%';
  ui.highscore.textContent = localStorage.getItem(HIGHKEY) || '0';
}

/* Start game */
startLevel(0);

/* small help: prevent accidental selection */
document.body.addEventListener('touchstart', e => { e.preventDefault(); }, {passive:false});
</script>
</body>
</html>

